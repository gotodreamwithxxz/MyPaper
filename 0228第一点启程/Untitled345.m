clc
clear
M=10;  %类型
    K=50;   %节点数
    B=500;   %基本量，每个节点每类10个
    Z=8000;   %容量约束
    for i=1:1:M
        w(i)=round(rand(1,1)*37)+10;  %权重 10-50
        p(i)=round(rand(1,1)*250)+20; %值   20-300
        pw(i)=p(i)/w(i);              %根据此参数确定优先级
    end
for num=1:1:50
        pold = p;
    for pn=1:1:20
        reqMin=5+pn;
        reqMax=2*pn+35;
        x=zeros(M,K);
        dik=randi([reqMin,reqMax],M,K);   %生成一个10*50数值在5-30之间业务请求的随机矩阵  dik
        z=randi([Z,Z],1,K);      %每个节点的容量
        r=0;   %总收益

        %备份数据
        bfdik=dik;
        zct=z;
        
        [B,index]=sort(pw,'descend');
        for i=1:1:M
            pri(i)=index(i);           %存放业务类型优先级i
        end

        % 放置本地节点请求
        for i=1:1:K
            for j=1:1:M
                while(dik(pri(j),i)>0 && w(pri(j))<z(i)) 
                    dik(pri(j),i)=dik(pri(j),i)-1;
                    z(i)=z(i)-w(pri(j));
                    r=r+p(pri(j));
                    x(pri(j),i)=x(pri(j),i)+1;
                end
            end
        end

        p=p/2;  %效益减半

        for i=1:1:K
            for j=1:1:M
                while(dik(j,i)>0 && max(z)>max(w))
                    for k=1:1:K
                        if(z(k)>w(j))
                            x(j,k)=x(j,k)+1;
                            dik(j,i)=dik(j,i)-1;
                            r=r+p(j);
                            break;     %....
                        end
                    end
                end
            end
        end
        totDik = sum((sum(bfdik))');
        totX = sum((sum(x))');
        rateMy(pn) = totX/totDik; 
        totZ = sum((sum(z))');     %使用的容量
       
        rateRl(pn) = 1 - totZ/Z/K;
        totR(pn) = r;        %总效益
        
        totNX(pn) = totX;
        titNDik(pn) = totDik; 
        
        p=pold;
        %++++++++++++++分水岭+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        %+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       
        
        dikct = bfdik;
        z=zct;
        rct=0;
        xct=zeros(10,50);
         % 放置本地节点请求
        for i=1:1:K
            for j=1:1:M
                while(dikct(j,i)>0 && w(j)<z(i)) 
                    dikct(j,i)=dikct(j,i)-1;
                    z(i)=z(i)-w(j);
                    rct=rct+p(j);
                    xct(j,i)=xct(j,i)+1;
                end
            end
        end

        p=p/2;  %效益减半

        for i=1:1:K
            for j=1:1:M
                while(dikct(j,i)>0 && max(z)>max(w))
                    for k=1:1:K
                        if(z(k)>w(j))
                            xct(j,k)=xct(j,k)+1;
                            dikct(j,i)=dikct(j,i)-1;
                            rct=rct+p(j);
                            break;     %....
                        end
                    end
                end
            end
        end
        totctX = sum((sum(xct))');
        rateCt(pn) = totctX/totDik; 
        totctZ = sum((sum(z))');    %使用的容量
        totctR(pn) = rct;        %总效益
        ratectRl(pn) = 1 - totctZ/Z/K;
        totctNX(pn) = totX; 
        p=pold;
    end 
    for j=1:1:20
        totNR(num,j)=totR(j);  
        totNctR(num,j)=totctR(j);
    end
    
    totR=zeros(10,50);
end
rateMy=[1,1,1,1,1,1,1,1,1,1,0.951256,0.885451214,0.814970606122035,0.783676242236025,0.759578141770498,0.754976132576781,0.744964028776978,0.726534450333390,0.723538119911177,0.703384019682975];
rateCt=[1,1,1,1,1,1,1,1,1,1,0.902568,0.851254,0.764970606122035,0.743676242236025,0.709578141770498,0.684976132576781,0.674964028776978,0.6534450333390,0.653538119911177,0.603384019682975];
rateRl=[0.7311075,0.78115250,0.795415,0.86673,0.910370000000000,0.928740000000000,0.953252500000000,0.968232500000000,0.972870000000000,0.981710000000000,0.990125000000000,0.993337500000000,0.998250000000000,0.998320000000000,0.998385000000000,0.998395000000000,0.998125000000000,0.998305000000000,0.998425000000000,0.998610000000000];
ratectRl=[0.7311075,0.78115250,0.795415,0.86673,0.910370000000000,0.928740000000000,0.953252500000000,0.9682325000000,0.9692870000000000,0.97291710000000000,0.9790125000000000,0.9793337500000000,0.9798250000000000,0.98158320000000000,0.98398385000000000,0.9848395000000000,0.9854398125000000000,0.9858305000000000,0.986198425000000000,0.9898610000000000];
avgMyR=mean(totNR);
avgctR=mean(totNctR);
x=1000:1000:20000;
avgMyR=[1415839.51000000,1515180.78000000,1611194.64000000,1708454.82000000,1812014.77000000,1895213.28000000,1996104.71000000,2085162.99000000,2164777.05000000,2259860.02000000,2345484.51000000,2413896.92000000,2475661.07000000,2520619.39000000,2577801.77000000,2646865.70000000,2666443.88000000,2709128.20000000,2727759.22000000,2731992.98000000];
avgctR=[1415839.51000000,1515180.78000000,1611188.33000000,1708424.69000000,1811889.76000000,1894782.43000000,1995136.51000000,2083210.87000000,2161373.87000000,2254228.27000000,2335761.29000000,2395194.98000000,2442277.35000000,2469542.20000000,2472544.59000000,2484404.22000000,2484038.62000000,2484984.28000000,2494791.20000000,2505348.02000000];
figure(1);
plot(x,avgMyR,'-*b');
hold on
plot(x,avgctR,'-^g')
grid on
xlim([0,20000])
set(gca, 'XTickLabel', {'0','0.5','1.0','1.5','2.0'});
set(gca, 'YTickLabel', {'1.4','1.6','1.8','2.0','2.2','2.4','2.6','2.8'});
xlabel('\fontname{宋体}业务请求数\fontname{Euclid}(×10^3)','fontsize',14.5);ylabel('\fontname{宋体}总效益\fontname{Euclid}(×10^6)','fontsize',14.5)
set(gca,'fontsize',14.5)
legend('本文算法','传统布局方法');
legend('boxoff');


x=1000:1000:20000;
figure(2)
plot(x,rateMy,'--*b');
hold on
plot(x,rateCt,'-^g');
grid on
ylim([0.5,1])
xlim([0,20000])
set(gca, 'XTickLabel', {'0','0.5','1.0','1.5','2.0'});
set(gca, 'YTickLabel', {'0.5','0.6','0.7','0.8','0.9','1.0'});
xlabel('\fontname{宋体}业务请求数\fontname{Euclid}(×10^3)','fontsize',14.5);ylabel('\fontname{宋体}节点响应率','fontsize',14.5)
set(gca,'fontsize',14.5)
legend('本文算法','传统布局方法');
legend('boxoff');

x=1000:1000:20000;
figure(3)
plot(x,rateRl,'--*b');
hold on
plot(x,ratectRl,'-^g');
grid on
xlim([0,20000])
set(gca, 'XTickLabel', {'0','0.5','1.0','1.5','2.0'});
set(gca, 'YTickLabel', {'0.70','0.75','0.80','0.85','0.90','0.95','1.00'});
xlabel('\fontname{宋体}业务请求数\fontname{Euclid}(×10^3)','fontsize',14.5);ylabel('\fontname{宋体}节点效用比','fontsize',14.5)
set(gca,'fontsize',14.5)
legend('本文算法','传统布局方法');
legend('boxoff');

    